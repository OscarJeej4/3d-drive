<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>3D Driving Game</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
    #ui {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      font-family: sans-serif;
      z-index: 10;
    }
    #speedometer {
      position: absolute;
      bottom: 10px;
      left: 10px;
      width: 120px;
      height: 120px;
      border: 2px solid white;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #needle {
      position: absolute;
      width: 2px;
      height: 60px;
      background: red;
      transform-origin: bottom center;
      bottom: 10px;
      left: 68px;
    }
    #minimap {
      position: absolute;
      top: 10px;
      right: 10px;
      width: 200px;
      height: 200px;
      border: 2px solid white;
    }
  </style>
</head>
<body>
  <div id="ui">
    <div id="speedometer">
      <div id="needle"></div>
    </div>
    <div id="speed">0 km/h</div>
  </div>
  <canvas id="minimap"></canvas>
  <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
  <script>
    (() => {
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      const miniRenderer = new THREE.WebGLRenderer({ canvas: document.getElementById('minimap'), alpha: true });
      miniRenderer.setSize(200, 200);
      const miniScene = new THREE.Scene();
      const miniCamera = new THREE.OrthographicCamera(-20, 20, 20, -20, 1, 100);

      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambientLight);
      const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
      dirLight.position.set(5, 10, 7.5);
      scene.add(dirLight);

      const groundSize = 200;
      const streetWidth = 4;
      const blockSize = 10;
      const citySize = 50;

      const ground = new THREE.Mesh(
        new THREE.PlaneGeometry(groundSize, groundSize),
        new THREE.MeshStandardMaterial({ color: 0x222222 })
      );
      ground.rotation.x = -Math.PI / 2;
      scene.add(ground);

      // Create roads
      const lineMaterial = new THREE.LineDashedMaterial({ color: 0xffff00, dashSize: 1, gapSize: 1 });
      for (let x = -citySize; x <= citySize; x += blockSize + streetWidth) {
        const road = new THREE.Mesh(
          new THREE.PlaneGeometry(streetWidth, groundSize),
          new THREE.MeshStandardMaterial({ color: 0x333333 })
        );
        road.rotation.x = -Math.PI / 2;
        road.position.x = x;
        scene.add(road);

        // Road line
        const points = [new THREE.Vector3(x, 0.01, -groundSize/2), new THREE.Vector3(x, 0.01, groundSize/2)];
        const lineGeo = new THREE.BufferGeometry().setFromPoints(points);
        const line = new THREE.Line(lineGeo, lineMaterial);
        line.computeLineDistances();
        scene.add(line);
      }
      for (let z = -citySize; z <= citySize; z += blockSize + streetWidth) {
        const road = new THREE.Mesh(
          new THREE.PlaneGeometry(groundSize, streetWidth),
          new THREE.MeshStandardMaterial({ color: 0x333333 })
        );
        road.rotation.x = -Math.PI / 2;
        road.position.z = z;
        scene.add(road);

        const points = [new THREE.Vector3(-groundSize/2, 0.01, z), new THREE.Vector3(groundSize/2, 0.01, z)];
        const lineGeo = new THREE.BufferGeometry().setFromPoints(points);
        const line = new THREE.Line(lineGeo, lineMaterial);
        line.computeLineDistances();
        scene.add(line);
      }

      // Create buildings
      const buildingBoxes = [];
      for (let x = -citySize; x < citySize; x += blockSize + streetWidth) {
        for (let z = -citySize; z < citySize; z += blockSize + streetWidth) {
          const building = new THREE.Mesh(
            new THREE.BoxGeometry(blockSize, Math.random() * 20 + 10, blockSize),
            new THREE.MeshStandardMaterial({ color: 0x888888 })
          );
          building.position.set(x + blockSize/2 + streetWidth, building.geometry.parameters.height/2, z + blockSize/2 + streetWidth);
          scene.add(building);
          const box = new THREE.Box3().setFromObject(building);
          buildingBoxes.push(box);
        }
      }

      // Car setup
      const carGeo = new THREE.BoxGeometry(1, 0.5, 2);
      const carMat = new THREE.MeshStandardMaterial({ color: 0xff0000 });
      const car = new THREE.Mesh(carGeo, carMat);
      car.position.set(streetWidth / 2, 0.25, streetWidth / 2); // Spawn on a road, not inside building
      scene.add(car);

      const miniCar = new THREE.Mesh(carGeo, new THREE.MeshBasicMaterial({ color: 0x0000ff }));
      miniScene.add(miniCar);

      let carSpeed = 0;
      const maxSpeed = 0.5;
      const acceleration = 0.002;
      const deceleration = 0.005;
      const steeringSpeed = 0.03;

      const keys = { forward: false, back: false, left: false, right: false };
      document.addEventListener('keydown', e => {
        if (e.key === 'w') keys.forward = true;
        if (e.key === 's') keys.back = true;
        if (e.key === 'a') keys.left = true;
        if (e.key === 'd') keys.right = true;
      });
      document.addEventListener('keyup', e => {
        if (e.key === 'w') keys.forward = false;
        if (e.key === 's') keys.back = false;
        if (e.key === 'a') keys.left = false;
        if (e.key === 'd') keys.right = false;
      });

      const carBox = new THREE.Box3().setFromObject(car);

      // Audio
      let audioCtx = null;
      let oscillator = null;
      let gainNode = null;

      function initSound() {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        oscillator = audioCtx.createOscillator();
        gainNode = audioCtx.createGain();
        oscillator.connect(gainNode).connect(audioCtx.destination);
        oscillator.start();
      }

      document.body.addEventListener('click', () => {
        if (!audioCtx) initSound();
      });

      function updateCar() {
        if(keys.forward) carSpeed += acceleration;
        else if(keys.back) carSpeed -= acceleration;
        else {
          if(carSpeed > 0) carSpeed -= deceleration;
          else if(carSpeed < 0) carSpeed += deceleration;
          if(Math.abs(carSpeed) < deceleration) carSpeed = 0;
        }

        carSpeed = THREE.MathUtils.clamp(carSpeed, -maxSpeed, maxSpeed);

        if(carSpeed !== 0) {
          if(keys.left) car.rotation.y += steeringSpeed * (carSpeed > 0 ? 1 : -1);
          if(keys.right) car.rotation.y -= steeringSpeed * (carSpeed > 0 ? 1 : -1);
        }

        const direction = new THREE.Vector3(0, 0, 1).applyEuler(car.rotation).multiplyScalar(carSpeed);
        const nextPos = car.position.clone().add(direction);
        carBox.setFromObject(car);
        carBox.min.add(direction);
        carBox.max.add(direction);

        let collided = false;
        for(const box of buildingBoxes) {
          if(carBox.intersectsBox(box)) {
            collided = true;
            break;
          }
        }

        if(collided) carSpeed = 0;
        else car.position.copy(nextPos);
      }

      function updateCamera() {
        const offset = new THREE.Vector3(0, 5, -12).applyEuler(car.rotation);
        camera.position.lerp(car.position.clone().add(offset), 0.1);
        camera.lookAt(car.position);
      }

      function updateSpeedometer() {
        const rotation = THREE.MathUtils.clamp(carSpeed / maxSpeed, -1, 1) * 90;
        document.getElementById('needle').style.transform = `rotate(${rotation}deg)`;
        document.getElementById('speed').textContent = `${Math.abs((carSpeed / maxSpeed) * 120).toFixed(0)} km/h`;
      }

      function updateMinimap() {
        miniCamera.position.set(car.position.x, 60, car.position.z);
        miniCamera.lookAt(car.position);
        miniCar.position.set(car.position.x, 0.25, car.position.z);
        miniCar.rotation.y = car.rotation.y;
      }

      function animate() {
        requestAnimationFrame(animate);
        updateCar();
        updateCamera();
        updateSpeedometer();
        updateMinimap();

        if(audioCtx) {
          oscillator.frequency.setValueAtTime(200 + Math.abs(carSpeed)*3500, audioCtx.currentTime);
          gainNode.gain.setValueAtTime(Math.abs(carSpeed)*0.15, audioCtx.currentTime);
        }

        renderer.render(scene, camera);
        miniRenderer.render(miniScene, miniCamera);
      }

      camera.position.set(0, 5, -10);
      camera.lookAt(0, 0, 0);
      animate();
    })();
  </script>
</body>
</html>
