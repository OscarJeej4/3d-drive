<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<title>3D Driving Game - City Streets & Minimap</title>
<style>
  body, html {
    margin: 0; padding: 0; overflow: hidden;
    background: #87ceeb;
    font-family: monospace, monospace;
    -webkit-tap-highlight-color: transparent;
  }
  #info {
    position: absolute;
    top: 10px; left: 10px;
    color: white;
    background: rgba(0,0,0,0.3);
    padding: 5px 10px;
    border-radius: 4px;
    max-width: 220px;
    user-select: none;
    z-index: 10;
  }
  #touchControls {
    position: absolute;
    bottom: 20px; left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 20px;
    z-index: 10;
  }
  .btn {
    width: 60px; height: 60px;
    border-radius: 30px;
    background: rgba(0,0,0,0.5);
    color: white;
    font-size: 24px;
    line-height: 60px;
    text-align: center;
    user-select: none;
  }
  #speedometer {
    position: absolute;
    bottom: 100px;
    left: 20px;
    width: 120px;
    height: 120px;
    background: rgba(0,0,0,0.5);
    border-radius: 60px;
    color: white;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    user-select: none;
    z-index: 10;
  }
  #speedometer .needle {
    width: 4px;
    height: 50px;
    background: red;
    position: relative;
    top: -15px;
    transform-origin: bottom center;
    transition: transform 0.1s ease-out;
    border-radius: 2px;
  }
  #speedValue {
    font-size: 20px;
    margin-top: 10px;
  }
  #minimap {
    position: absolute;
    top: 10px;
    right: 10px;
    width: 200px;
    height: 200px;
    border: 2px solid white;
    border-radius: 8px;
    background: rgba(0,0,0,0.5);
    z-index: 10;
  }
</style>
</head>
<body>

<div id="info">
  Controls: W/S = Forward/Back, A/D = Left/Right<br/>
  Or use the touch buttons below.
</div>

<div id="touchControls">
  <div id="leftBtn" class="btn">◀️</div>
  <div id="forwardBtn" class="btn">▲</div>
  <div id="backBtn" class="btn">▼</div>
  <div id="rightBtn" class="btn">▶️</div>
</div>

<div id="speedometer">
  <div class="needle" id="needle"></div>
  <div id="speedValue">0 km/h</div>
</div>

<div id="minimap"></div>

<script src="https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.min.js"></script>
<script>
(() => {
  // Scene Setup
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x87ceeb);
  const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
  camera.position.set(0, 5, -10);

  const renderer = new THREE.WebGLRenderer({antialias: true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // Mini-map Setup
  const miniScene = new THREE.Scene();
  const miniCamera = new THREE.OrthographicCamera(-30, 30, 30, -30, 0.1, 1000);
  miniCamera.position.set(0, 60, 0);
  miniCamera.lookAt(0, 0, 0);

  const miniRenderer = new THREE.WebGLRenderer({antialias: true, alpha: true});
  miniRenderer.setSize(200, 200);
  miniRenderer.setClearColor(0x000000, 0);
  document.getElementById('minimap').appendChild(miniRenderer.domElement);

  // Ground
  const groundGeo = new THREE.PlaneGeometry(220, 220);
  const groundMat = new THREE.MeshStandardMaterial({color: 0x222222});
  const ground = new THREE.Mesh(groundGeo, groundMat);
  ground.rotation.x = -Math.PI / 2;
  scene.add(ground);

  // Lighting
  scene.add(new THREE.AmbientLight(0xffffff, 0.5));
  const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
  directionalLight.position.set(5, 10, 7);
  scene.add(directionalLight);

  // Car Setup
  const carGeometry = new THREE.BoxGeometry(1, 0.5, 2);
  const carMaterial = new THREE.MeshStandardMaterial({color: 0xff0000});
  const car = new THREE.Mesh(carGeometry, carMaterial);
  car.position.y = 0.25;
  scene.add(car);

  // Mini car
  const miniCarMaterial = new THREE.MeshBasicMaterial({color: 0x0000ff});
  const miniCar = new THREE.Mesh(carGeometry, miniCarMaterial);
  miniCar.position.y = 0.25;
  miniScene.add(miniCar);

  // Variables
  let carSpeed = 0;
  const maxSpeed = 0.12;
  const acceleration = 0.002; // slower acceleration for realism
  const deceleration = 0.0018;
  const steeringSpeed = 0.03;
  let keys = {forward: false, back: false, left: false, right: false};
  let buildingBoxes = [];

  // Buildings & Streets
  const buildings = [];
  const citySize = 100;
  const blockSize = 10;
  const streetWidth = 6;

  // Create roads and dashed center lines
  function createRoadsAndLines() {
    const lineMaterial = new THREE.LineDashedMaterial({
      color: 0xFFFF00,
      dashSize: 1,
      gapSize: 1.2,
      linewidth: 2
    });

    for (let z = -citySize; z <= citySize; z += blockSize + streetWidth) {
      // Horizontal roads
      const roadGeo = new THREE.PlaneGeometry(citySize * 2, streetWidth);
      const roadMat = new THREE.MeshStandardMaterial({color: 0x444444});
      const road = new THREE.Mesh(roadGeo, roadMat);
      road.rotation.x = -Math.PI / 2;
      road.position.z = z + streetWidth/2;
      scene.add(road);

      // Yellow dashed line horizontally
      const points = [new THREE.Vector3(-citySize, 0.02, z + streetWidth/2), new THREE.Vector3(citySize, 0.02, z + streetWidth/2)];
      const lineGeo = new THREE.BufferGeometry().setFromPoints(points);
      const line = new THREE.Line(lineGeo, lineMaterial);
      line.computeLineDistances();
      scene.add(line);
    }

    for (let x = -citySize; x <= citySize; x += blockSize + streetWidth) {
      // Vertical roads
      const roadGeo = new THREE.PlaneGeometry(streetWidth, citySize * 2);
      const roadMat = new THREE.MeshStandardMaterial({color: 0x444444});
      const road = new THREE.Mesh(roadGeo, roadMat);
      road.rotation.x = -Math.PI / 2;
      road.position.x = x + streetWidth/2;
      scene.add(road);

      // Yellow dashed line vertically
      const points = [new THREE.Vector3(x + streetWidth/2, 0.02, -citySize), new THREE.Vector3(x + streetWidth/2, 0.02, citySize)];
      const lineGeo = new THREE.BufferGeometry().setFromPoints(points);
      const line = new THREE.Line(lineGeo, lineMaterial);
      line.computeLineDistances();
      scene.add(line);
    }
  }

  // Create buildings between streets
  function createBuildings() {
    const buildingColors = [0x555555, 0x666666, 0x777777, 0x888888];

    for (let x = -citySize; x < citySize; x += blockSize + streetWidth) {
      for (let z = -citySize; z < citySize; z += blockSize + streetWidth) {
        const height = 3 + Math.random() * 7;
        const bGeo = new THREE.BoxGeometry(blockSize, height, blockSize);
        const bMat = new THREE.MeshStandardMaterial({color: buildingColors[Math.floor(Math.random() * buildingColors.length)]});
        const building = new THREE.Mesh(bGeo, bMat);
        building.position.set(x + blockSize/2, height/2, z + blockSize/2);
        scene.add(building);
        buildings.push(building);

        const box = new THREE.Box3().setFromObject(building);
        buildingBoxes.push(box);

        // Mini-map buildings in gray
        const miniBGeo = new THREE.BoxGeometry(blockSize, height, blockSize);
        const miniBMat = new THREE.MeshBasicMaterial({color: 0x666666});
        const miniBuilding = new THREE.Mesh(miniBGeo, miniBMat);
        miniBuilding.position.copy(building.position);
        miniScene.add(miniBuilding);
      }
    }
  }

  createRoadsAndLines();
  createBuildings();

  // Bounding box for car collision detection
  const carBox = new THREE.Box3();

  // Audio setup
  let audioCtx, oscillator, gainNode;
  try {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    oscillator = audioCtx.createOscillator();
    oscillator.type = 'sawtooth';
    gainNode = audioCtx.createGain();
    gainNode.gain.value = 0;
    oscillator.connect(gainNode).connect(audioCtx.destination);
    oscillator.start();
  } catch (e) {
    audioCtx = null;
  }

  // Controls
  window.addEventListener('keydown', (e) => {
    switch(e.code) {
      case 'KeyW': case 'ArrowUp': keys.forward = true; break;
      case 'KeyS': case 'ArrowDown': keys.back = true; break;
      case 'KeyA': case 'ArrowLeft': keys.left = true; break;
      case 'KeyD': case 'ArrowRight': keys.right = true; break;
    }
  });

  window.addEventListener('keyup', (e) => {
    switch(e.code) {
      case 'KeyW': case 'ArrowUp': keys.forward = false; break;
      case 'KeyS': case 'ArrowDown': keys.back = false; break;
      case 'KeyA': case 'ArrowLeft': keys.left = false; break;
      case 'KeyD': case 'ArrowRight': keys.right = false; break;
    }
  });

  // Touch controls
  function setupTouchBtn(id, key) {
    const btn = document.getElementById(id);
    btn.addEventListener('touchstart', e => { e.preventDefault(); keys[key] = true; }, { passive: false });
    btn.addEventListener('touchend', e => { e.preventDefault(); keys[key] = false; }, { passive: false });
  }
  setupTouchBtn('forwardBtn', 'forward');
  setupTouchBtn('backBtn', 'back');
  setupTouchBtn('leftBtn', 'left');
  setupTouchBtn('rightBtn', 'right');

  // UI Elements
  const needle = document.getElementById('needle');
  const speedValue = document.getElementById('speedValue');

  // Resize handler
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

  // Main update loop
  function animate() {
    requestAnimationFrame(animate);
    updateCar();
    updateCamera();
    updateSpeedometer();
    updateMinimap();
    renderer.render(scene, camera);
    miniRenderer.render(miniScene, miniCamera);
  }

  function updateCar() {
    // Acceleration & braking logic (slower for realism)
    if (keys.forward) {
      carSpeed += acceleration;
    } else if (keys.back) {
      carSpeed -= acceleration;
    } else {
      if (carSpeed > 0) carSpeed -= deceleration;
      else if (carSpeed < 0) carSpeed += deceleration;
      if (Math.abs(carSpeed) < deceleration) carSpeed = 0;
    }

    carSpeed = THREE.MathUtils.clamp(carSpeed, -maxSpeed, maxSpeed);

    // Steering only if moving
    if (carSpeed !== 0) {
      if (keys.left) car.rotation.y += steeringSpeed * (carSpeed > 0 ? 1 : -1);
      if (keys.right) car.rotation.y -= steeringSpeed * (carSpeed > 0 ? 1 : -1);
    }

    // Calculate next position
    const direction = new THREE.Vector3(0, 0, 1);
    direction.applyEuler(car.rotation);
    direction.multiplyScalar(carSpeed);
    const nextPos = car.position.clone().add(direction);

    // Update bounding box at next position
    carBox.setFromObject(car);
    carBox.min.add(direction);
    carBox.max.add(direction);

    // Collision detection with buildings
    let collided = false;
    for (const box of buildingBoxes) {
      if (carBox.intersectsBox(box)) {
        collided = true;
        break;
      }
    }

    if (collided) {
      carSpeed = 0; // Stop immediately on collision
    } else {
      car.position.copy(nextPos);
    }

    // Keep car inside city bounds
    const limit = citySize - blockSize;
    car.position.x = THREE.MathUtils.clamp(car.position.x, -limit, limit);
    car.position.z = THREE.MathUtils.clamp(car.position.z, -limit, limit);

    // Update audio pitch & volume based on speed
    if (audioCtx) {
      oscillator.frequency.setValueAtTime(200 + Math.abs(carSpeed) * 3000, audioCtx.currentTime);
      gainNode.gain.setValueAtTime(Math.abs(carSpeed) * 0.15, audioCtx.currentTime);
    }
  }

  function updateCamera() {
    // Smooth follow from behind the car
    const offset = new THREE.Vector3(0, 5, -10);
    offset.applyEuler(car.rotation);
    const desiredPos = car.position.clone().add(offset);

    camera.position.lerp(desiredPos, 0.1);
    camera.lookAt(car.position);
  }

  function updateSpeedometer() {
    // Map speed (-maxSpeed to maxSpeed) to needle rotation (-90deg to 90deg)
    const rotation = THREE.MathUtils.clamp(carSpeed / maxSpeed, -1, 1) * 90;
    needle.style.transform = `rotate(${rotation}deg)`;
    speedValue.textContent = `${Math.abs((carSpeed / maxSpeed) * 120).toFixed(0)} km/h`;
  }

  function updateMinimap() {
    // Center mini-camera on car's x,z
    miniCamera.position.set(car.position.x, 60, car.position.z);
    miniCamera.lookAt(car.position.x, 0, car.position.z);

    // Update mini car position & rotation
    miniCar.position.set(car.position.x, 0.25, car.position.z);
    miniCar.rotation.y = car.rotation.y;
  }

  animate();
})();
</script>

</body>
</html>
